---
title: "Application of Deep Learning in Multi-omics Data"
author: "张昕奕 朱瑾煜"
date: '2022-06-29'
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(tidyverse)
library(readr)
library(ggthemes)
```

## Abstract

Autoencoder is widely applied in deep learning. By applying autoencoder, this work  clusters and classfies different type of blood cells, compares encoding results from UMAP and t-sne, and results from CITE-seq data and RNA-seq data only.


## 1 Introduction
Autoencoder (AE) is a kind of **A**rtificial **N**eural **N**etworks (ANNs) used in semi-supervised and unsupervised learning. ANNs belongs to the field of deep learning. Its function is to conduct representational learning of input information by taking input information as the learning target, which is usually used for compression dimension reduction, style transfer and outlier detection, etc.  

The autoencoder is divided into two parts. The first part is encoder, generally a multi-layer network, which compresses the input data into a vector, into low dimensions (*bottleneck*). The second part is the decoder, which outputs the reconstructed input data. Our goal is to make the reconstructed data the same as the original data, so as to achieve the function of compression and restoration. Meanwhile, the loss function is used to minimize the distance between the reconstructed data and the original data. 

Based on the basic principles of AE and relevant codes, this work attempts to describe the training process and show the clustering results of different type of blood cells, and also comparing the accuracy and clustering discrepancy between with and without data integration and comparing encoding results from UMAP and t-sne.
  
  
## 2 Methods and Materials
### 2.1 Data source   
Data files `metadata.csv.gz`, `protein_scale.csv.gz` and `rna_scale.csv.gz` used in this work are generated by running the R script `processing.R`.

### 2.2 Softwares and packages
Softwares applied in this project are mainly `Python` (version 3.9.12) and `R` (version 4.2.0). Package `PyTorch` in `Python` is used for deep learning, and packages `tidyverse` and `ggplot2` in `R` are used for data analysis and plotting.

### 2.3 Scripts  
Scripts, including `Python` scripts and `R` scripts applied in this project are attached in the zipped file.

## 3 Results 
### 3.1 Model based on CITE-seq data

Run script `autoencoder_citeseq.py` to implement training. The plot in Figure 1 shows the training process. 

(*Data attached: LossesRes.txt*)

```{r echo=TRUE,message=FALSE}
LossesRes <- read.csv("LossesRes.txt", sep="")
p1 <- ggplot(data=LossesRes, aes(x=col)) + geom_path(aes(y=train,color="train") ) + geom_path(aes(y=valid,color="valid")) + labs(caption = "Figure 1. Training process of CITE-seq data", x = "", y = "") + theme(plot.caption=element_text(size=10,hjust=0.5,color="blue"))
p1
```

Figure 2 indicates the clustering result.  
(*Data attached: umapRes.csv*)

```{r echo=TRUE,message=FALSE}
umapRes <- read.csv("umapRes.csv")

ggplot(data = umapRes) + 
  geom_point(mapping = aes(x = UMAP1, y = UMAP2, color = celltype.l1.5)) + labs(caption = "Figure 2. Clustering result based on CITE-seq data") + theme(plot.caption=element_text(size=10,hjust=0.5,color="blue"))
```

Figure 2 shows the UMAP visualization of bottleneck features. According to the result, it can be easily observed that:

1. Cells of the same type cluster together.  
2. Some types of cells are not clearly distinguished. For example, gdt and MAIT clusters link quite tightly to each other,which may indicate that they have relative similar characters.
3. Generally B cell, CD4 T and NK cell show best distinguishment among the types.   

### 3.2 Model based on RNA-seq data only

While the model generated in Section 3.1 is based on CITE-seq data, i.e., data from both transcriptome and epitopes, we attempt to generate a model with RNA-seq data only, in order to compare these two models. We run the modified script `autoencoder_citeseq_gene.py` to implement training, and Figure 3 shows the training process. 

(*Data attached: LossesResNucl.txt*)

```{r echo=TRUE,message=FALSE}
LossesRes <- read.csv("LossesResNucl.txt", sep="")
p1 <- ggplot(data=LossesRes, aes(x=col)) + geom_path(aes(y=train,color="train") ) + geom_path(aes(y=valid,color="valid")) + labs(caption = "Figure 3. Training process of RNA-seq data", x = "", y = "") + theme(plot.caption=element_text(size=10,hjust=0.5,color="blue"))
p1
```

Figure 4 indicates the clustering result.  
(*Data attached: nuclRes.csv*)

```{r echo=TRUE,message=FALSE}
umapRes <- read.csv("nuclRes.csv")

ggplot(data = umapRes) + 
  geom_point(mapping = aes(x = UMAP1, y = UMAP2, color = celltype.l1.5)) + labs(caption = "Figure 4. Clustering result based on RNA-seq data") + theme(plot.caption=element_text(size=10,hjust=0.5,color="blue"))
```

Figure 4 still shows clustered cells and rather good distinguishment. However, its distinguishment (or resolution) is relatively low than Figure 2, whose model is generated from CITE-seq data. For example, it is hard to sort CD8 T cells from CD4 T cells in Figure 4, while it is much easier in Figure 2.

### 3.3 Model based on t-SNE

Run the script `t-SNE.py` to cluster the very same encoding results by t-SNE, visualize it and compare with UMAP result (Figure 5). 
(*optionC.py Data attached: tsneRes.csv*)  

```{r echo=TRUE,message=FALSE}
tsneRes <- read.csv("tsneRes.csv")
ggplot(data = tsneRes) + 
  geom_point(mapping = aes(x = UMAP1, y = UMAP2, color = celltype.l1.5)) + labs(caption = "Figure 5. Clustering result based on t-SNE", x = "TSNE1", y = "TSNE2") + theme(plot.caption=element_text(size=10,hjust=0.5,color="blue"))

```  
    
Figure 5 shows the t-sne visualization result. Comparing this result to the former UMAP one (Figure 2, Figure 4), t-sne let one type of cell be broken into separate parts, such as CD8 T is separated into mainly 3 parts. Therefore, the cells are better clustered in UMAP. However,t-sne shows more distinguished separation among cell types,especially between gdt and MAIT. When operating the script, we find that t-sne tends to take more time than UMAP.  
  
## 4 Discussion

### 4.1 Comparison between t-SNE and UMAP results

Based on the observation and relevant information in Section 3.1 and 3.3: [^1][^2]

**1. Global Structure**

When using tSNE dimensional-reduction single cell data, it is often found that cells of the same class are separated by other cells. This is because its loss function (KL divergence) penalizes low dimensional near and high dimensional far less, resulting in clusters with small overall differences that may be farther apart than clusters with large differences in the plane. Therefore, tSNE graph cannot reflect the real global structure in most cases.  
The UMAP loss function uses binary cross entropy, which imposes heavier penalties on low-dimensional near high-dimensional far or low-dimensional far high-dimensional near, so UMAP can better reflect the real global structure than tSNE.   

**2. Local Structure**

The local structure of tSNE is more compact. Since tSNE uses Gaussian distribution to convert probability when fitting high-dimensional data, low-dimensional data uses T-distribution to convert probability, which will make the point with a close distance in high-dimensional space closer in low-dimensional space, and vice versa.

**3. Time Complexity** 

The time complexity of tSNE is $O(n^2)$, and that of UMAP is $O(n^{1.14})$. When dimensionality reduction is performed on hundreds of thousands of flow cytometry data and single cell data, UMAP can improve several times or even tens of times faster than tSNE.

**4. Others**

TSNE uses random distribution to initialize low-dimensional data, while UMAP uses Graph Laplace transform to allocate initial low-dimensional coordinates (low-dimensional data is initialized according to characteristics of high-dimensional data), so UMAP results have higher stability.  

**5. How to choose between t-SNE and UMAP**

In application, the algorithm should be selected according to the actual situation.  
To be specific, UMAP has the advantages of high speed and better global structure. T-sne shows better local structure and may be suitable for small data size.

### 4.2 Comparison between CITE-seq and RNA-seq results

**1. Principles**

CITE-seq, or **C**ellular **I**ndexing of **T**ranscriptomes and **E**pitopes by **Seq**uencing, is a multimodal single-cell phenotyping method which offers gene expression and surface protein information simultaneously at a single-cell level [^3]. 

CITE-seq simultaneously measures gene expression and surface protein at a single-cell level. To handle the data given from CITE-seq, we need to load both `rna_scale.csv.gz` and `protein_scale.csv.gz` files, then use the Python function `pd.concat()` to concat or integrate them in one table, used for model training and further modification. While data from RNA-seq only need no integration step.

**2. Comparison on resolution**

Comparison between Figure 2 and Figure 4 indicates that although model based on RNA-seq only has good distinguishment (or resolution) among Mono/DC, progenitor, T and B cells, it is still hard to tell CD4 T cells from CD8 T cells. Knowledge from immunology may explain this apparently strange phenomenon. That is, CD4 T cells (or helper T cells) and CD8 T (or inhibitory/cytotoxic T cells) are differentiated from the common lymphoid progenitor in the bone marrow and mature in the thymus [^4][^5]. As T cells that share the same genome and metabolic pathways, they tend to express the same genes. However, their antigens presented on the surface of the cell membrane can be very different. CD4 T cells express CD4 glycoprotein on the surface, while CD8 T cells express CD8 glycoprotein on the surface. Generally, CD4 and CD8 T cells share most of their transctiptomes, but are different in Epitopes, and therefore it is hard to distinguish them using only RNA-seq data, but easy to tell them using integrated CITE-seq data.

**3. Comparison on speed (time complexity)**

In this project, generating the model based on CITE-seq costs 2 min 46 s, while generating the model based on only RNA-seq costs 2 min 22 s. The difference between them is not significant, and therefore the omission of surface protein information does not save much time. That is probably because the algorithms used are the same (UMAP), with the same complexity $O(n^{1.14})$, so omitting part of the data does not make much sense.


**4. Application**

Since RNA-seq-only method does not save much time compared with CITE-seq method, and that CITE-seq method gives more accurate results, we should always build the model from the entire CITE-seq data, if possible.


### 4.3 Notes

When try to operate scripts in virtual environment, we ran into problem that UMAP cannot be imported. The problem may lies that there may be a permission problem that does not include all paths in the virtual environment when activating the virtual environment. With T.A.'s help we solve it by copy `umap.etc` files to the current running directory.  

## 5 Acknowledgement  
Thanks to Teacher Liu Fenglin and T.A. Yang Xinyu!

## References
[^1]: Do, V.H., Canzar, S. A generalization of t-SNE and UMAP to single-cell multimodal omics. Genome Biol 22, 130 (2021). <https://doi.org/10.1186/s13059-021-02356-5>.
[^2]: tSNE and UMAP, Li's Bioinfo-Blog. 
<https://lishensuo.github.io/posts/bioinfo/112%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er13--%E9%99%8D%E7%BB%B4t-sne%E4%B8%8Eumap/>.
[^3]: CITE-seq. <https://cite-seq.com/>.
[^4]: Janeway CA Jr, et al. Immunobiology: The Immune System in Health and Disease. 5th edition. New York: Garland Science; 2001. Chapter 8, T Cell-Mediated Immunity.
[^5]: Janeway CA Jr, Travers P, Walport M, et al. Immunobiology: The Immune System in Health and Disease. 5th edition. New York: Garland Science; 2001. T cell-mediated cytotoxicity.